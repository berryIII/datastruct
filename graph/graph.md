## 概念
1. 简单图，无环无重边。
2. 度，结点的边数，有向图中度=出度+入度。
3. 完全图与有向完全图，边数达到最大值，即n(n-1)/2与n(n-1)
4. 稀疏图和稠密图，边数较少或较多。
5. 加权图（网），边带有附加信息，包括无向加权图和有向加权图。
6. 若无向图中任意两点都是可达的（有路径），则称该无向图是连通图，若是有向图，则称其为强连通图。 
7. 无向图中的极大连通子图为连通分量，若无向图是连通的，则连通分量只有一个。有向图的连通分量叫强连通分量，有多个。连通分量总和的结点数为n，不多不少。
8. 生成树，连通图（无向连通）的一个极小连通子图（包含n个节点），该子图一定仅具有n-1条边（反之未必），生成树可以有多个。
9. 对无向图而言，n个结点的图若边数少于n-1，则必非连通，若超过n-1个，则必有回路。

##
```
         C— - — D
        / \    /
       /   \  /
      A — - B
```
```
         C
        / \    
       /   \  
      A ——>  B
      \_
       \
        \
         D
```

## 存储
1.邻接矩阵存储
|-|0|1|2|3|
|-|-|-|-|-|
|0|0|1|1|0|
|1|1|0|1|1|
|2|1|1|0|1|
|3|0|1|1|0|

特点
1. 无向图存储是对称矩阵
2. 空间复杂度o(n^2)
3. 可以很快判断两点间是否有边
4. 稀疏图时浪费存储
5. 计算总边数需要遍历矩阵。

2.邻接表
i|-|-|
-|-|-|
0|A|->B->C|
1|B|->A->C->D|
2|C|->A->B->D|
3|D|->B->C|

特点
1. 空间复杂度o(n+e)，n为结点数，e为边数
2. 无向图时有重复存储
3. 判断两点是否有边需要遍历链表
4. 存储结构不唯一。

## 遍历
深度优先
```c
dfs(node[n],visited[n],start){
    visit(node[start]);
    visited[start]=1;
    for(j in node[start].neighbors){
        if(visited[j]!=1){
            dfs(node,visited,j);
        }
    }
}
```
空间复杂度O(n)，时间复杂度O(n^2)或O(n+e)

广度优先
```c
bfs(node[n],visited[n],start){
    queue q;
    inqueue(q,start);
    while(nonEmpty(q)){
        cur=dequeue(q);
        visit(node[cur]);
        visited[cur]=1;
        for(j in node[cur].neighbors){
            if(visited[j]!=1){
                inqueue(q,j);
            }
        }
    }
}
```
复杂度与深度优先相同。

## 连通分量
检测无向图是否连通，或计算有多少个连通分量，使用dfs/bfs进行x次搜索，将全部结点访问一遍，则x个连通分量。

对于有向图而言，若要判断是否连通，无法像无向图那样进行一次dfs/bfs，根据是否访问全部结点判断（不同的起点结果可能不同）。
一个直观的办法是对从每个结点开始搜索一次，这种情况最坏时间复杂度为o(n*(n+e))。

## 环检测
对无向图而言，可以从起点遍历看是否能回到该点，dfs/bfs均可。

拓扑排序<br>
从入度为0的点开始访问，访问后更新该邻接点的入度信息，重复这个过程，直到访问完所有结点，或者有环。时间复杂度O(n+e)。
```c
topologicalSort(node[n]){
    // 统计各结点入度数
    int indegree[n];
    for(i=0;i<n;i++){
        indegree[i]=0;
    }
    for(i=0;i<n;i++){
        for(j in node[i].neighbors){
            indegree[j]+=1;
        }
    }

    // 使用队列顺序访问所有入度为0的结点
    queue q;
    for(i=0;i<n;i++){
        if(indegree[i]==0){
            inqueue(q,i);
        }
    }
    int visited=0;
    while(nonEmpty(q)){
        cur=dequeue(q);
        visit(cur);
        visited+=1;
        for(j in node[cur].neighbors){
            indegree[j]-=1;
            if(indegree[j]==0){
                inqueue(q,j);
            }
        }
    }
    if(visited!=n){
        print("cycle exits.")
    }
}
```

## 最小生成树
连通图具有n个顶点，从图中选择n-1条边，即为生成树。如果是从带权的连通图中选择n-1条边，使得权值总和最小，则该树为最小生成树。

prim算法<br>
源于图切割思想，将图的顶点分为两个集合u和v，初始状态u为全部结点，v为空，将初始顶点s由u移入v中，将连接u和v的最小权值边所对应的顶点再由u移入v中，不断重复这个过程，直到v包含所有结点。<br>
可以借助最小堆实现寻找最小权值边的过程，首先将起始顶点的所有边加入堆中，然后每次从堆中取出最小权值的边，如果这个边的两个点分别在u和v，则将在u的那端的顶点加入v中，再将其所有边中未访问过的加入堆中，不断重复，直到堆为空。

prim的时间复杂度取决于具体实现，一些教材上说是O(n^2)，因此其适合稠密图，这是不准确的，实际上借助堆和邻接表，时间复杂度可接近O(E*logV)。

kruskal算法<br>
类似于贪心策略，先将所有的边进行排序，每次将最小权值边加入集合中，如果因为这条边加入导致形成了环，则放弃这条边，直到所有顶点都在这个边的集合中。<br>
每次得到最小边后，可以检测边的两个端点是否在并查集中已经连通，如果已经连通，则再加入这条边必然引起环，否则可以加入。

借助快排和并查集等结构，时间复杂度可降至O(E*logE)

## 最短路径
对无权图而言，可以借助广度优先直接获得最短路径。

dijkstra算法<br>
对带权图（有向和无向）通常可以借助dijkstra算法解决单源最短路径的问题，算法具有贪心性质，在没有负权边的情况下，当下已经的从start到其他各个点的路径中最小的那个必然是一个最短路径，因为如果由其他结点中转耗费必然更大。<br>

一个简单的实现是维护一个数组cost[n+1],cost[i]代表由start到i的最短路径，外层循环对所有结点遍历，内层循环扫描cost数组，得到最短路径cost[j]后，计算通过j中转其他结点k是否当前cost[k]小，即`cost[j]+weight[j][k]<cost[k]`,如果成立则更新cost[k]的值，继续遍历下一个结点，由于每次外层循环后都能确定到一个点的最短路径，因此n轮循环后就可以确定完整的单源最短路径了。<br>

整体来说，上述的实现dijkstra算法时间复杂度为O(n^2)，基于邻接矩阵实现，使用索引堆等结构优化后可达到O(E*logV)。

bellman-ford算法<br>
可以处理负权边，是一种动态规划思想的算法，时间复杂度可以做到O(EV)。

## 带权图（网）
AOV网（Activity of Vertex)<br>
关于活动的有向图，结点表示活动，有向边表示活动间的依赖关系，可以借助拓扑排序检测是否可以完成。

AOE网（Activity of Edge)<br>
关于活动的带有权值的有向无环图，用边表示活动，边上的权值表示活动的开销，结点表示事件，通常用于判断工程的完成时间等。<br>
关键路径，从源点到终点的最大路径长度，该路径成为关键路径，路径上的活动是关键活动，这个路径的长度是工程的最短工期。


